# CPU-Windows-Scheduler
CPU scheduler for windows operating system using C language
CPU scheduler that implements three scheduling algorithms: first come first serve, shortest job first and longest job first.

The scheduler runs according to a program contained in the file ("ComputeProgram_64.exe") that takes on command line agument, a positive integer and then computes for that many seconds of CPU time (not wall-clock-time, but combined usert-time and kernel-time). The program keeps track of exactly how much CPU time it has accumulated and it stops exactly when the given number of CPU seconds. The notation SECONDS... represents a list of positive integer values. The integer values are execution times for instances of the program "computeProgram64.exe". For example, consider running the scheduler with this command-line.Z:\ hw4> hw4 6 12 4 5 10

When the scheduler program starts up, it should use the GetProcessAffinityMask() function to ask the operating system which processors are being made available to it. Suppose the operating system makes three CPU's available to the scheduler program and they are CPU's 0, 3 and 5. The scheduler should then use the CreateProcess() function to run three instances of computeProgram_64.exe, a 6 second instance on CPU 0, a 12 second instance on CPU 3 and a 4 second instance on CPU 5 (the scheduler should use the SetProcessAffinityMask() function to tell the operating system to assign each process to a specific CPU; the details of this step are given in a paragraph below). The scheduler program should then use the WaitForMultipleObjects() function to wait for one of the running processes to finish (the details of this step are also given in a paragraph below). When the 4 second instance on CPU 5 finishes, the scheduler should run a 5 second instance on CPU 5 and then wait again, using WaitForMultipleObjects(), for one of its child processes to finish. When the 6 second instance finishes on CPU 0, the scheduler should run a 10 second instance on CPU 0. Since there are no more new instances to run, the scheduler should wait, again using WaitForMultipleObjects(), for each of the currently running processes to finish.

Since initially there are no processors running processes, the scheduler should intitially launch as many processes as there are available processors (or until there are no more processes to run) In order to start launching processes, we have to call CreateProcess() and the operating system will immediatly start up the new process. But the operating system will start the process on whichever CPU it wants to, not the specific CPU that you want to assign the process to. In order to get a chance to call SetProcessAffinityMask() for the new process, we need to tell CreateProcess() to create the new process in the "suspended state". We create a process in the suspended state by using the CREATE_SUSPENDED Process Creation Flag in CreateProcess' dwCreationFlags parameter. (The dwCreationFlags parameter is another example of a bitmask. Each process creation flag is just one bit. We combine creation flags by bitwise or'ing the bits together. For example, the bitmask CREATE_NEW_CONSOLE|CREATE_SUSPENDED|DEBUG_PROCESS has three bits set.) After the new process has been created suspended, we can use the new process's handle to call SetProcessAffinityMask() to assign the process to a specific processor (we get the correct affinity mask by looking at the affinityMask field in this processor's entry in the processorPool array).

Once all processors are busy with their initial jobs, the scheduler should go into a loop where it waits for a process to end and then launches the new process. The scheduler should stay in this loop until there are no new processes launch and there are no processes still running on any processor. Now that we have the scheduler written and working, we add a feature to it that makes experimenting with the scheduler easy. The new feature is to have the scheduler implement three different scheduling algorithms, first come first serve (FCFS), shortest job first (SJF), and longest job first (LJF). The new version of the scheduler has the following command-line syntax.

hw4 SCHEDULE_TYPE SECONDS...
Where: SCHEDULE_TYPE = 0 means "first come first serve"
SCHEDULE_TYPE = 1 means "shortest job first"
SCHEDULE_TYPE = 2 means "longest job first"
